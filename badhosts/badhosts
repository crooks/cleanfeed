#!/usr/bin/python
#
# vim: tabstop=4 expandtab shiftwidth=4 autoindent
#
# badhosts.py -- Auto-management of the cleanfeed bad_hosts file
#
# Copyright (C) 2005 Steve Crook <steve@mixmin.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.

import bsddb
import datetime
import re
import sys
import config
from os import path

def utcnow():
    """Just return the utc time.  Everything should work on utc."""
    utctime = datetime.datetime.utcnow()
    utcstamp = utctime.strftime("%Y-%m-%d %H:%M:%S")
    return utcstamp

def hours_ago(past_hours):
    """Return a timestamp for a given number of hours prior to utc."""
    thentime = datetime.datetime.utcnow() - datetime.timedelta(hours=past_hours)
    timestamp = thentime.strftime("%Y-%m-%d %H:%M:%S")
    return timestamp

def file_to_list(name):
    """Read a file and return each line as an element of a list"""
    list = []
    if not path.exists(name):
        return list 
    file = open(name, 'r')
    tmplist = file.readlines()
    file.close()
    #TODO: I hate reading a whole file and then parsing it to strip LF's
    for item in tmplist:
        list.append(item.rstrip())
    return list

def dictkeys_to_list(dict):
    """Take a Dictionary and return it's keys as a sorted list"""
    list = dict.keys()
    list.sort()
    return list

def populate_hosts(filename):
    """Read a file produced by Cleanfeed that contains all the rejected
    NNTP-Posting-Host entries.  Return this info as a Dictionary, keyed by
    hostname and containing a count of each rejected message."""
    hosts = {}
    # Try and open the file from which we will read the cleanfeed rejects
    try:
        file = open(filename, 'r')
    except IOError:
        sys.stdout.write("File %s not found\n" % (filename,))
        sys.exit(1)
    # Populate a dictionary keyed by hostname
    for line in file:
        line = line.rstrip()
        if hosts.has_key(line):
            hosts[line] += 1
        else:
            hosts[line] = 1
    return hosts

def update_hosts_db(hosts):
    """For entries in our hosts dictionary that exceed the threshold of rejected
    messages, update the timestamp to utcnow in our db_hosts database."""
    now = utcnow()
    for key in hosts:
        key = key.rstrip()
        if hosts[key] >= config.threshold:
            db_hosts[key] = now
    db_hosts.sync()

def regcheck(badhost):
    """Compare a given host with all the entries in our excluded_hosts file.
    Entries can be plain text matches or regex if the entry in exclude_hosts is
    wrapped within slashes."""
    excluded = False
    for regex in exclude_hosts:
        # Entries wrapped in /.../ are regex format.
        if regex.startswith('/') and regex.endswith('/'):
            regex = regex.strip('/')
            if re.match(regex, badhost):
                excluded = True
                break
        # If entry is not regex, do a plain-text compare.
        else:
            if badhost == regex:
                excluded = True
                break
    return excluded
    
def housekeeping(expire):
    """Expire entries from our database where the timestamp is prior
    to a defined age."""
    age = hours_ago(expire)
    for key in db_hosts.keys():
        if db_hosts[key] < age:
            del db_hosts[key]
    db_hosts.sync()

def write_bad_hosts(filename):
    """Write the keys of our hosts dictionary to the actual bad_hosts file.
    This is the file we then distribute as bad_hosts_central."""
    try:
        file = open(filename, 'w')
    except IOError:
        sys.stdout.write("File %s could not be written\n" % (filename,))
        sys.exit(1)
    file.write('######################################################\n')
    file.write('# This file is downloaded from a central resource.   #\n')
    file.write('# Do not manually edit it as your changes will be    #\n')
    file.write('# overwritten during the next scheduled download.    #\n')
    file.write('# For manual listings, update the bad_hosts file.    #\n')
    file.write('######################################################\n\n')
    host_addys = dictkeys_to_list(db_hosts)
    for entry in host_addys:
        if not regcheck(entry):
            file.write('%s\n' % (entry,))
            print db_hosts[entry], entry
    file.close()

def db_delete(regex_text):
    """Manually delete entries from the database.  Remember that they will get
    reinstated with the next run if entries within the current Cleanfeed
    rejects file still exceeds the threshold."""
    hits = 0
    deletes = []
    regex = re.compile(regex_text)
    for key in db_hosts.keys():
        match = regex.match(key)
        if match:
            sys.stdout.write('%s matched for deletion\n' % key)
            deletes.append(key)
            hits += 1
    sys.stdout.write('Matching entries: %s\n' % hits)
    if hits:
        confirm = raw_input("Are you sure? (yes/no): ")
        confirm = confirm.lower()
        if confirm == "yes":
            for key in deletes:
                sys.stdout.write("%s deleted\n" % key)
                del db_hosts[key]
            db_hosts.sync()
        else:
            sys.stdout.write("Deletion cancelled\n")

def db_insert(entry):
    """Manually add an entry to the database.  If the entry already exists,
    the timestamp will be reset to utcnow."""
    entry = entry.rstrip()
    if db_hosts.has_key(entry):
        sys.stdout.write("%s already in DB.  Refreshing timestamp\n" % entry)
    else:
        sys.stdout.write("Adding %s to badhost DB\n" % entry)
    db_hosts[entry] = utcnow()

def cmd_args(args):
    """Return a mode variable based on what arguement we're passed:
    Mode is used to identify what we're going to do.  Current modes are:-
    0     Normal operation with no command line arguements.
    1     Delete database entries matching a supplies regex.
    2     Manual insert into database"""
    mode = 0
    # Check if we're being passed an arguement on the command line
    if len(args) > 1:
        # Command switches must start with -- or be ignored.
        if args[1].startswith('--'):
            # Strip the -- and put the remainder in option.
            option = args[1] [2:]
            if len(args) > 2:
                if option == 'delete':
                    mode = 1
                    db_delete(args[2])
                if option == 'insert':
                    mode = 2
                    db_insert(args[2])
    return mode

def main():
    # Open a Berkeley style database containing hostnames and timestamps.
    global db_hosts
    db_hosts = bsddb.hashopen(config.dbfile)

    mode = cmd_args(sys.argv)

    if mode == 0:
        # Populate a dictionary keyed by hostname, containing the number of
        # occurances of each hostname within the Cleanfeed report file.
        hosts = populate_hosts(config.report_file)
        # Populate a list with the hosts we wish to exclude from filtering. We
        # do this in main() to avoid recursion.
        global exclude_hosts
        exclude_hosts = file_to_list(config.exclude_file)
        # Create or update entries in the database with the current timestamp
        # if they exceed a threshold of occurances.
        update_hosts_db(hosts)
        # Parse the database and remove expired entries.
        housekeeping(config.expire)
        # Write the database payload to a text file for cleanfeed to use.
        write_bad_hosts(config.badhosts_textfile)
    db_hosts.close()

if (__name__ == "__main__"):
    main()
