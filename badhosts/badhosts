#!/usr/bin/python
#
# vim: tabstop=4 expandtab shiftwidth=4 autoindent
#
# badhosts.py -- Auto-management of the cleanfeed bad_hosts file
#
# Copyright (C) 2005 Steve Crook <steve@mixmin.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.

import bsddb
import datetime
import re
import sys
import config
from os import path

def utcnow():
    """Just return the utc time.  Everything should work on utc."""
    utctime = datetime.datetime.utcnow()
    utcstamp = utctime.strftime("%Y-%m-%d %H:%M:%S")
    return utcstamp

def hours_ago(past_hours):
    """Return a timestamp for a given number of hours prior to utc. This
    is used by housekeeping to clear expired entries from the request and
    dupcheck databases."""
    thentime = datetime.datetime.utcnow() - datetime.timedelta(hours=past_hours)
    timestamp = thentime.strftime("%Y-%m-%d %H:%M:%S")
    return timestamp

def file_to_list(name):
    list = []
    if not path.exists(name):
        return list 
    file = open(name, 'r')
    tmplist = file.readlines()
    file.close()
    for item in tmplist:
        list.append(item.rstrip())
    return list

def populate_hosts(filename):
    hosts = {}
    # Try and open the file from which we will read the cleanfeed rejects
    try:
        file = open(filename, 'r')
    except IOError:
        sys.stdout.write("File %s not found\n" % (filename,))
        sys.exit(1)
    # Populate a dictionary keyed by hostname
    for line in file:
        re_test = host_re.match(line)
        if re_test:
            foo = re_test.group(1)
            if hosts.has_key(foo):
                hosts[foo] += 1
            else:
                hosts[foo] = 1
    return hosts

def update_hosts_db(exclude):
    now = utcnow()
    for key in hosts:
        if hosts[key] >= config.threshold and \
        key not in exclude:
            db_hosts[key] = now
    db_hosts.sync()

def housekeeping(expire):
    age = hours_ago(expire)
    for key in db_hosts.keys():
        if db_hosts[key] < age:
            print "%s\t%s\tExpired" % (db_hosts[key], key)
            del db_hosts[key]
        else:
            print "%s\t%s" % (db_hosts[key], key)
    db_hosts.sync()

def write_bad_hosts(filename):
    try:
        file = open(filename, 'w')
    except IOError:
        sys.stdout.write("File %s could not be written\n" % (filename,))
        sys.exit(1)
    file.write('######################################################\n')
    file.write('# This file is downloaded from a central resource.   #\n')
    file.write('# Do not manually edit it as your changes will be    #\n')
    file.write('# overwritten during the next scheduled download.    #\n')
    file.write('# For manual listings, update the bad_hosts file.    #\n')
    file.write('######################################################\n\n')
    for key in db_hosts.keys():
        file.write('%s\n' % (key,))
    file.close()

def db_delete(regex_text):
    hits = 0
    deletes = []
    regex = re.compile(regex_text)
    for key in db_hosts.keys():
        match = regex.match(key)
        if match:
            sys.stdout.write('%s matched for deletion\n' % key)
            deletes.append(key)
            hits += 1
    sys.stdout.write('Matching entries: %s\n' % hits)
    if hits:
        confirm = raw_input("Are you sure? (yes/no): ")
        confirm = confirm.lower()
        if confirm == "yes":
            for key in deletes:
                sys.stdout.write("%s deleted\n" % key)
                del db_hosts[key]
            db_hosts.sync()
        else:
            sys.stdout.write("Deletion cancelled\n")

def cmd_args(args):
    # Mode is used to identify what we're going to do.  Current modes are:-
    # 0     Normal operation with no command line arguements.
    # 1     Delete database entries matching a supplies regex.
    mode = 0
    # Check if we're being passed an arguement on the command line
    if len(args) > 1:
        if args[1].startswith('--'):
            option = args[1] [2:]
            if option == 'delete' and len(args) > 2:
                mode = 1
                db_delete(args[2])
    return mode


# Regex used to extract hosts
# TODO There is a risk that a clever abuser could include this in the
#      message payload in order to seed innocent hosts.
host_re = re.compile('^NNTP-Posting-Host: (.*)')

db_hosts = bsddb.hashopen(config.dbfile)

mode = cmd_args(sys.argv)

if mode == 0:
    hosts = populate_hosts(config.report_file)
    exclude_hosts = file_to_list(config.exclude_file)
    update_hosts_db(exclude_hosts)
    housekeeping(config.expire)
    write_bad_hosts(config.badhosts_textfile)
db_hosts.close()
