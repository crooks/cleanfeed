#!/usr/bin/python
#
# vim: tabstop=4 expandtab shiftwidth=4 autoindent
#
# badhosts.py -- Auto-management of the cleanfeed bad_hosts file
#
# Copyright (C) 2005 Steve Crook <steve@mixmin.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.

import bsddb
import datetime
import re
import sys
import config
from os import path

def utcnow():
    """Just return the utc time.  Everything should work on utc."""
    utctime = datetime.datetime.utcnow()
    utcstamp = utctime.strftime("%Y-%m-%d %H:%M:%S")
    return utcstamp

def hours_ago(past_hours):
    """Return a timestamp for a given number of hours prior to utc. This
    is used by housekeeping to clear expired entries from the request and
    dupcheck databases."""
    thentime = datetime.datetime.utcnow() - datetime.timedelta(hours=past_hours)
    timestamp = thentime.strftime("%Y-%m-%d %H:%M:%S")
    return timestamp

def file_to_list(name):
    list = []
    if not path.exists(name):
        return list 
    file = open(name, 'r')
    tmplist = file.readlines()
    file.close()
    for item in tmplist:
        list.append(item.rstrip())
    return list

def populate_hosts(filename):
    hosts = {}
    # Try and open the file from which we will read the cleanfeed rejects
    try:
        file = open(filename, 'r')
    except IOError:
        sys.stdout.write("File %s not found\n" % (filename,))
        sys.exit(1)
    # Populate a dictionary keyed by hostname
    for line in file:
        re_test = host_re.match(line)
        if re_test:
            foo = re_test.group(1)
            if hosts.has_key(foo):
                hosts[foo] += 1
            else:
                hosts[foo] = 1
    return hosts

def update_hosts_db(exclude):
    now = utcnow()
    for key in hosts:
        if hosts[key] >= config.threshold and \
        key not in exclude:
            db_hosts[key] = now
    db_hosts.sync()

def housekeeping(expire):
    age = hours_ago(expire)
    for key in db_hosts.keys():
        if db_hosts[key] < age:
            print "%s\t%s\tExpired" % (db_hosts[key], key)
            del db_hosts[key]
        else:
            print "%s\t%s" % (db_hosts[key], key)
    db_hosts.sync()

def write_bad_hosts(filename):
    try:
        file = open(filename, 'w')
    except IOError:
        sys.stdout.write("File %s could not be written\n" % (filename,))
        sys.exit(1)
    file.write('######################################################\n')
    file.write('# This file is downloaded from a central resource.   #\n')
    file.write('# Do not manually edit it as your changes will be    #\n')
    file.write('# overwritten during the next scheduled download.    #\n')
    file.write('# For manual listings, update the bad_hosts file.    #\n')
    file.write('######################################################\n\n')
    for key in db_hosts.keys():
        file.write('%s\n' % (key,))
    file.close()

# Regex used to extract hosts
# TODO There is a risk that a clever abuser could include this in the
#      message payload in order to seed innocent hosts.
host_re = re.compile('^NNTP-Posting-Host: (.*)')

# Check if we're being passed an arguement on the command line
if len(sys.argv) > 1:
    option = sys.argv[1]
else:
    option = config.report_file
hosts = populate_hosts(option)

db_hosts = bsddb.hashopen(config.dbfile)
exclude_hosts = file_to_list(config.exclude_file)
update_hosts_db(exclude_hosts)
housekeeping(config.expire)
write_bad_hosts(config.badhosts_textfile)
db_hosts.close()
